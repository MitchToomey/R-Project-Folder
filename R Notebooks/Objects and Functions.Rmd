---
title: "Objects and Functions"
author: "Michael A. Seaman"
output: html_notebook
---

In this notebook we will explore the basics of objects and functions. 
Everything that exists is an object. Everything that happens is a function
call.

### Objects

All objects have a mode, class, and type. The mode is the classification of
the basic structure of the object. THe class is a property of the object that
determines how functions can operate on that object. The type tells what is
contained within the object.

For us to do anything in R, we need to use function calls because "everything
that happens is a function call." Here I will use three function calls to
look at an object.

```{r include=FALSE}

mode(2)
class(2)
typeof(2)

```

There are four basic modes for data objects: numeric, complex, character, and
logical. What is more important to us is the class of the object, so that is
what I'm going to focus on throughout the course.

#### Atomic Vectors

An atomic vector is a sequence of data of the same type. To build vectors,
we "concatenate" the members of the sequence with the concatenate function.
We can then assign this to an object we create with a name that we choose.

```{r include=FALSE}

# Here is an example of a vector.

even_nums <- c(2, 4, 6, 8, 10, 12, 14, 16)

# We can see the class of this object.

class(even_nums)

# We can also see the type of data.

typeof(even_nums)

# If we want to force the vector to be integers, we need to add L.
# We shouldn't need to do this, but now we know what R means when
# the output includes L.

even_nums_2 <- c(2L, 4L, 6L, 8L, 10L, 12L, 14L, 16L)

class(even_nums_2)
typeof(even_nums_2)

# Here's a vector of logical values.

true_or_false <- c(TRUE, TRUE, FALSE, TRUE, FALSE)

class(true_or_false)
typeof(true_or_false)

# Here's a vector of characters.

our_course <- c("E", "D", "R", "M", "7", "1", "8")

class(our_course)
typeof(our_course)

# What if we put multiple characters between quotes? These are called
# strings, but they still are part of the same class. Technically, a
# string is one or more characters, so characters are strings.

our_course_2 <- c("EDRM", "718")

class(our_course_2)
typeof(our_course_2)

```

#### Implicit Coercion

When we mix data types when creating a vector, this becomes an atomic vector
through implicit coercion. Data at "lower levels" are changed to a higher
level.

```{r include=FALSE}

different_types <- c(2L, 4L, 6.2, 8.8)

class(different_types)
typeof(different_types)

different_types_2 <- c(TRUE, TRUE, FALSE, "EDRM", "718")

class(different_types_2)
typeof(different_types_2)

different_types_3 <- c(TRUE, TRUE, FALSE, 2L, 4L)

class(different_types_3)
typeof(different_types_3)

different_types_4 <- c(TRUE, 2L, 4, "EDRM")

class(different_types_4)
typeof(different_types_4)

```

#### Checking Data Type

As we will see later, it is often useful to check for the type of data with
a function that returns a logical value. The "is" functions do this for us.

```{r}

# We can also check the type of data in a vector using the "is" functions.

is.integer(even_nums)
is.double(even_nums)

is.integer(even_nums_2)

# Watch what happens when we ask whether the vector is numeric.

is.numeric(even_nums)
is.numeric(even_nums_2)

# A couple more useful is statements.

is.logical(true_or_false)
is.character(our_course)
is.atomic(our_course)
is.vector(even_nums)

```

#### Other Useful Vector Functions

We have seen that function calls are of the form function_name(stuff) where
we send the function something in parentheses. As we will discuss in more
detail later, the "stuff" in the parentheses is called an "argument".

Here we look at a few more useful vector functions.

```{r}

# Other Useful Vector Functions -------------------------------------------

# We can explicitly coerce vectors into different data types.

logic_to_numeric <- as.numeric(true_or_false)
numeric_to_character <- as.character(even_nums)
numeric_to_logical <- as.logical(even_nums)

# We can find out how many elements are in a vector_

length(even_nums)

# Even a scalar is a vector of length 1_

my_scalar <- 5
length(my_scalar)
length(5)

# We indicate that an element of a vector is missing with NA_

my_data <- c(59, 62, 65, 62, 60, 65, 64, NA, 70, 69, 61, 63, 58)

# Let's check for missing data_

is.na(my_data)

```

#### Attributes

Objects in R have attributes, just as objects in the real world have
attributes. Some of these are built-in to objects of a certain class, but we
can change attributes and even create new attributes.

```{r}

# We can check the attributes of an object.

attributes(even_nums)

# We can add attributes to an object.

names(even_nums) <- c("two", "four", "six", "eight", "ten", "twelve",
                      "fourteen", "sixteen")

even_nums

attributes(even_nums)

# Names can be added when we create an object.

odd_nums <- c("one" = 1, "three" = 3, "five" = 5, "seven" = 7)

odd_nums

# We can add comments to an object.

comment(even_nums) <- c("A list of even numbers", "Created 17 Jan 2021")

attributes(even_nums)

# We can even create attributes.

attr(even_nums, "category") <- "even numbers"

attributes(even_nums)

```
